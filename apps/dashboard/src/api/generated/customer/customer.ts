/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Navigator API
 * Backend API for Navigator (FastAPI). Auth via Cognito JWT; customer tenancy derived from JWT.

 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Customer,
  CustomerUpdate,
  GetCustomerTokens200,
  GetCustomersCustomerIdTokens200,
  Problem,
  TokenBalanceUpdate
} from '.././model';

import { customFetch } from '../../client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Stripe is source of truth for billing/tax/contact. This endpoint returns what we store/cached.

 * @summary Get customer metadata (mostly Stripe-linked)
 */
export type getCustomerResponse200 = {
  data: Customer
  status: 200
}
    
export type getCustomerResponseSuccess = (getCustomerResponse200) & {
  headers: Headers;
};
;

export type getCustomerResponse = (getCustomerResponseSuccess)

export const getGetCustomerUrl = () => {


  

  return `/customer`
}

export const getCustomer = async ( options?: RequestInit): Promise<getCustomerResponse> => {
  
  return customFetch<getCustomerResponse>(getGetCustomerUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerQueryKey = () => {
    return [
    `/customer`
    ] as const;
    }

    
export const getGetCustomerQueryOptions = <TData = Awaited<ReturnType<typeof getCustomer>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomer>>> = ({ signal }) => getCustomer({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomer>>>
export type GetCustomerQueryError = unknown


export function useGetCustomer<TData = Awaited<ReturnType<typeof getCustomer>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomer>>,
          TError,
          Awaited<ReturnType<typeof getCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomer<TData = Awaited<ReturnType<typeof getCustomer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomer>>,
          TError,
          Awaited<ReturnType<typeof getCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomer<TData = Awaited<ReturnType<typeof getCustomer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer metadata (mostly Stripe-linked)
 */

export function useGetCustomer<TData = Awaited<ReturnType<typeof getCustomer>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomer>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Use this only for non-billing fields you want cached in Navigator.
Billing/tax/contact should typically be updated in Stripe.

 * @summary Update locally-stored customer fields (optional)
 */
export type patchCustomerResponse200 = {
  data: Customer
  status: 200
}
    
export type patchCustomerResponseSuccess = (patchCustomerResponse200) & {
  headers: Headers;
};
;

export type patchCustomerResponse = (patchCustomerResponseSuccess)

export const getPatchCustomerUrl = () => {


  

  return `/customer`
}

export const patchCustomer = async (customerUpdate: CustomerUpdate, options?: RequestInit): Promise<patchCustomerResponse> => {
  
  return customFetch<patchCustomerResponse>(getPatchCustomerUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customerUpdate,)
  }
);}




export const getPatchCustomerMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomer>>, TError,{data: CustomerUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchCustomer>>, TError,{data: CustomerUpdate}, TContext> => {

const mutationKey = ['patchCustomer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCustomer>>, {data: CustomerUpdate}> = (props) => {
          const {data} = props ?? {};

          return  patchCustomer(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof patchCustomer>>>
    export type PatchCustomerMutationBody = CustomerUpdate
    export type PatchCustomerMutationError = unknown

    /**
 * @summary Update locally-stored customer fields (optional)
 */
export const usePatchCustomer = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomer>>, TError,{data: CustomerUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchCustomer>>,
        TError,
        {data: CustomerUpdate},
        TContext
      > => {
      return useMutation(getPatchCustomerMutationOptions(options), queryClient);
    }
    /**
 * @summary Archive current customer
 */
export type deleteCustomerResponse200 = {
  data: Customer
  status: 200
}

export type deleteCustomerResponse409 = {
  data: Problem
  status: 409
}
    
export type deleteCustomerResponseSuccess = (deleteCustomerResponse200) & {
  headers: Headers;
};
export type deleteCustomerResponseError = (deleteCustomerResponse409) & {
  headers: Headers;
};

export type deleteCustomerResponse = (deleteCustomerResponseSuccess | deleteCustomerResponseError)

export const getDeleteCustomerUrl = () => {


  

  return `/customer`
}

export const deleteCustomer = async ( options?: RequestInit): Promise<deleteCustomerResponse> => {
  
  return customFetch<deleteCustomerResponse>(getDeleteCustomerUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteCustomerMutationOptions = <TError = Problem,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomer>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCustomer>>, TError,void, TContext> => {

const mutationKey = ['deleteCustomer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCustomer>>, void> = () => {
          

          return  deleteCustomer(requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCustomer>>>
    
    export type DeleteCustomerMutationError = Problem

    /**
 * @summary Archive current customer
 */
export const useDeleteCustomer = <TError = Problem,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCustomer>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCustomer>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getDeleteCustomerMutationOptions(options), queryClient);
    }
    /**
 * @summary Get customer by id
 */
export type getCustomersCustomerIdResponse200 = {
  data: Customer
  status: 200
}
    
export type getCustomersCustomerIdResponseSuccess = (getCustomersCustomerIdResponse200) & {
  headers: Headers;
};
;

export type getCustomersCustomerIdResponse = (getCustomersCustomerIdResponseSuccess)

export const getGetCustomersCustomerIdUrl = (customerId: string,) => {


  

  return `/customers/${customerId}`
}

export const getCustomersCustomerId = async (customerId: string, options?: RequestInit): Promise<getCustomersCustomerIdResponse> => {
  
  return customFetch<getCustomersCustomerIdResponse>(getGetCustomersCustomerIdUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomersCustomerIdQueryKey = (customerId: string,) => {
    return [
    `/customers/${customerId}`
    ] as const;
    }

    
export const getGetCustomersCustomerIdQueryOptions = <TData = Awaited<ReturnType<typeof getCustomersCustomerId>>, TError = unknown>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomersCustomerIdQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomersCustomerId>>> = ({ signal }) => getCustomersCustomerId(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomersCustomerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomersCustomerId>>>
export type GetCustomersCustomerIdQueryError = unknown


export function useGetCustomersCustomerId<TData = Awaited<ReturnType<typeof getCustomersCustomerId>>, TError = unknown>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerId>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerId<TData = Awaited<ReturnType<typeof getCustomersCustomerId>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerId>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerId<TData = Awaited<ReturnType<typeof getCustomersCustomerId>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer by id
 */

export function useGetCustomersCustomerId<TData = Awaited<ReturnType<typeof getCustomersCustomerId>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomersCustomerIdQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update customer by id
 */
export type patchCustomersCustomerIdResponse200 = {
  data: Customer
  status: 200
}
    
export type patchCustomersCustomerIdResponseSuccess = (patchCustomersCustomerIdResponse200) & {
  headers: Headers;
};
;

export type patchCustomersCustomerIdResponse = (patchCustomersCustomerIdResponseSuccess)

export const getPatchCustomersCustomerIdUrl = (customerId: string,) => {


  

  return `/customers/${customerId}`
}

export const patchCustomersCustomerId = async (customerId: string,
    customerUpdate: CustomerUpdate, options?: RequestInit): Promise<patchCustomersCustomerIdResponse> => {
  
  return customFetch<patchCustomersCustomerIdResponse>(getPatchCustomersCustomerIdUrl(customerId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      customerUpdate,)
  }
);}




export const getPatchCustomersCustomerIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerId>>, TError,{customerId: string;data: CustomerUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerId>>, TError,{customerId: string;data: CustomerUpdate}, TContext> => {

const mutationKey = ['patchCustomersCustomerId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCustomersCustomerId>>, {customerId: string;data: CustomerUpdate}> = (props) => {
          const {customerId,data} = props ?? {};

          return  patchCustomersCustomerId(customerId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchCustomersCustomerIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchCustomersCustomerId>>>
    export type PatchCustomersCustomerIdMutationBody = CustomerUpdate
    export type PatchCustomersCustomerIdMutationError = unknown

    /**
 * @summary Update customer by id
 */
export const usePatchCustomersCustomerId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerId>>, TError,{customerId: string;data: CustomerUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchCustomersCustomerId>>,
        TError,
        {customerId: string;data: CustomerUpdate},
        TContext
      > => {
      return useMutation(getPatchCustomersCustomerIdMutationOptions(options), queryClient);
    }
    /**
 * @summary List customers
 */
export type getCustomersResponse200 = {
  data: Customer[]
  status: 200
}
    
export type getCustomersResponseSuccess = (getCustomersResponse200) & {
  headers: Headers;
};
;

export type getCustomersResponse = (getCustomersResponseSuccess)

export const getGetCustomersUrl = () => {


  

  return `/customers`
}

export const getCustomers = async ( options?: RequestInit): Promise<getCustomersResponse> => {
  
  return customFetch<getCustomersResponse>(getGetCustomersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomersQueryKey = () => {
    return [
    `/customers`
    ] as const;
    }

    
export const getGetCustomersQueryOptions = <TData = Awaited<ReturnType<typeof getCustomers>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomers>>> = ({ signal }) => getCustomers({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomersQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomers>>>
export type GetCustomersQueryError = unknown


export function useGetCustomers<TData = Awaited<ReturnType<typeof getCustomers>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomers>>,
          TError,
          Awaited<ReturnType<typeof getCustomers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomers<TData = Awaited<ReturnType<typeof getCustomers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomers>>,
          TError,
          Awaited<ReturnType<typeof getCustomers>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomers<TData = Awaited<ReturnType<typeof getCustomers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List customers
 */

export function useGetCustomers<TData = Awaited<ReturnType<typeof getCustomers>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomers>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Get token balance
 */
export type getCustomerTokensResponse200 = {
  data: GetCustomerTokens200
  status: 200
}
    
export type getCustomerTokensResponseSuccess = (getCustomerTokensResponse200) & {
  headers: Headers;
};
;

export type getCustomerTokensResponse = (getCustomerTokensResponseSuccess)

export const getGetCustomerTokensUrl = () => {


  

  return `/customer/tokens`
}

export const getCustomerTokens = async ( options?: RequestInit): Promise<getCustomerTokensResponse> => {
  
  return customFetch<getCustomerTokensResponse>(getGetCustomerTokensUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomerTokensQueryKey = () => {
    return [
    `/customer/tokens`
    ] as const;
    }

    
export const getGetCustomerTokensQueryOptions = <TData = Awaited<ReturnType<typeof getCustomerTokens>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomerTokensQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomerTokens>>> = ({ signal }) => getCustomerTokens({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomerTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomerTokens>>>
export type GetCustomerTokensQueryError = unknown


export function useGetCustomerTokens<TData = Awaited<ReturnType<typeof getCustomerTokens>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerTokens>>,
          TError,
          Awaited<ReturnType<typeof getCustomerTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerTokens<TData = Awaited<ReturnType<typeof getCustomerTokens>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomerTokens>>,
          TError,
          Awaited<ReturnType<typeof getCustomerTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomerTokens<TData = Awaited<ReturnType<typeof getCustomerTokens>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get token balance
 */

export function useGetCustomerTokens<TData = Awaited<ReturnType<typeof getCustomerTokens>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomerTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomerTokensQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Credit customer token balance
 */
export type postCustomersCustomerIdTokensCreditResponse200 = {
  data: Customer
  status: 200
}
    
export type postCustomersCustomerIdTokensCreditResponseSuccess = (postCustomersCustomerIdTokensCreditResponse200) & {
  headers: Headers;
};
;

export type postCustomersCustomerIdTokensCreditResponse = (postCustomersCustomerIdTokensCreditResponseSuccess)

export const getPostCustomersCustomerIdTokensCreditUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/tokens/credit`
}

export const postCustomersCustomerIdTokensCredit = async (customerId: string,
    tokenBalanceUpdate: TokenBalanceUpdate, options?: RequestInit): Promise<postCustomersCustomerIdTokensCreditResponse> => {
  
  return customFetch<postCustomersCustomerIdTokensCreditResponse>(getPostCustomersCustomerIdTokensCreditUrl(customerId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tokenBalanceUpdate,)
  }
);}




export const getPostCustomersCustomerIdTokensCreditMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext> => {

const mutationKey = ['postCustomersCustomerIdTokensCredit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>, {customerId: string;data: TokenBalanceUpdate}> = (props) => {
          const {customerId,data} = props ?? {};

          return  postCustomersCustomerIdTokensCredit(customerId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostCustomersCustomerIdTokensCreditMutationResult = NonNullable<Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>>
    export type PostCustomersCustomerIdTokensCreditMutationBody = TokenBalanceUpdate
    export type PostCustomersCustomerIdTokensCreditMutationError = unknown

    /**
 * @summary Credit customer token balance
 */
export const usePostCustomersCustomerIdTokensCredit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postCustomersCustomerIdTokensCredit>>,
        TError,
        {customerId: string;data: TokenBalanceUpdate},
        TContext
      > => {
      return useMutation(getPostCustomersCustomerIdTokensCreditMutationOptions(options), queryClient);
    }
    /**
 * @summary Debit customer token balance
 */
export type postCustomersCustomerIdTokensDebitResponse200 = {
  data: Customer
  status: 200
}

export type postCustomersCustomerIdTokensDebitResponse409 = {
  data: Problem
  status: 409
}
    
export type postCustomersCustomerIdTokensDebitResponseSuccess = (postCustomersCustomerIdTokensDebitResponse200) & {
  headers: Headers;
};
export type postCustomersCustomerIdTokensDebitResponseError = (postCustomersCustomerIdTokensDebitResponse409) & {
  headers: Headers;
};

export type postCustomersCustomerIdTokensDebitResponse = (postCustomersCustomerIdTokensDebitResponseSuccess | postCustomersCustomerIdTokensDebitResponseError)

export const getPostCustomersCustomerIdTokensDebitUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/tokens/debit`
}

export const postCustomersCustomerIdTokensDebit = async (customerId: string,
    tokenBalanceUpdate: TokenBalanceUpdate, options?: RequestInit): Promise<postCustomersCustomerIdTokensDebitResponse> => {
  
  return customFetch<postCustomersCustomerIdTokensDebitResponse>(getPostCustomersCustomerIdTokensDebitUrl(customerId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tokenBalanceUpdate,)
  }
);}




export const getPostCustomersCustomerIdTokensDebitMutationOptions = <TError = Problem,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext> => {

const mutationKey = ['postCustomersCustomerIdTokensDebit'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>, {customerId: string;data: TokenBalanceUpdate}> = (props) => {
          const {customerId,data} = props ?? {};

          return  postCustomersCustomerIdTokensDebit(customerId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostCustomersCustomerIdTokensDebitMutationResult = NonNullable<Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>>
    export type PostCustomersCustomerIdTokensDebitMutationBody = TokenBalanceUpdate
    export type PostCustomersCustomerIdTokensDebitMutationError = Problem

    /**
 * @summary Debit customer token balance
 */
export const usePostCustomersCustomerIdTokensDebit = <TError = Problem,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>, TError,{customerId: string;data: TokenBalanceUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postCustomersCustomerIdTokensDebit>>,
        TError,
        {customerId: string;data: TokenBalanceUpdate},
        TContext
      > => {
      return useMutation(getPostCustomersCustomerIdTokensDebitMutationOptions(options), queryClient);
    }
    /**
 * @summary Get customer token balance
 */
export type getCustomersCustomerIdTokensResponse200 = {
  data: GetCustomersCustomerIdTokens200
  status: 200
}
    
export type getCustomersCustomerIdTokensResponseSuccess = (getCustomersCustomerIdTokensResponse200) & {
  headers: Headers;
};
;

export type getCustomersCustomerIdTokensResponse = (getCustomersCustomerIdTokensResponseSuccess)

export const getGetCustomersCustomerIdTokensUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/tokens`
}

export const getCustomersCustomerIdTokens = async (customerId: string, options?: RequestInit): Promise<getCustomersCustomerIdTokensResponse> => {
  
  return customFetch<getCustomersCustomerIdTokensResponse>(getGetCustomersCustomerIdTokensUrl(customerId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomersCustomerIdTokensQueryKey = (customerId: string,) => {
    return [
    `/customers/${customerId}/tokens`
    ] as const;
    }

    
export const getGetCustomersCustomerIdTokensQueryOptions = <TData = Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError = unknown>(customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomersCustomerIdTokensQueryKey(customerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>> = ({ signal }) => getCustomersCustomerIdTokens(customerId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomersCustomerIdTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>>
export type GetCustomersCustomerIdTokensQueryError = unknown


export function useGetCustomersCustomerIdTokens<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError = unknown>(
 customerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTokens<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTokens<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get customer token balance
 */

export function useGetCustomersCustomerIdTokens<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError = unknown>(
 customerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTokens>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomersCustomerIdTokensQueryOptions(customerId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




