/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Navigator API
 * Backend API for Navigator (FastAPI). Auth via Cognito JWT; customer tenancy derived from JWT.

 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetTestsParams,
  PagedTargetTests,
  TargetTest,
  TargetTestCreate,
  TargetTestUpdate,
  TestDecisionAnswer,
  TestDecisionState
} from '.././model';

import { customFetch } from '../../client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List tests (across all targets in tenant)
 */
export type getTestsResponse200 = {
  data: PagedTargetTests
  status: 200
}
    
export type getTestsResponseSuccess = (getTestsResponse200) & {
  headers: Headers;
};
;

export type getTestsResponse = (getTestsResponseSuccess)

export const getGetTestsUrl = (params?: GetTestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/tests?${stringifiedParams}` : `/tests`
}

export const getTests = async (params?: GetTestsParams, options?: RequestInit): Promise<getTestsResponse> => {
  
  return customFetch<getTestsResponse>(getGetTestsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTestsQueryKey = (params?: GetTestsParams,) => {
    return [
    `/tests`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTestsQueryOptions = <TData = Awaited<ReturnType<typeof getTests>>, TError = unknown>(params?: GetTestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTests>>> = ({ signal }) => getTests(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTestsQueryResult = NonNullable<Awaited<ReturnType<typeof getTests>>>
export type GetTestsQueryError = unknown


export function useGetTests<TData = Awaited<ReturnType<typeof getTests>>, TError = unknown>(
 params: undefined |  GetTestsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTests>>,
          TError,
          Awaited<ReturnType<typeof getTests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTests<TData = Awaited<ReturnType<typeof getTests>>, TError = unknown>(
 params?: GetTestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTests>>,
          TError,
          Awaited<ReturnType<typeof getTests>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTests<TData = Awaited<ReturnType<typeof getTests>>, TError = unknown>(
 params?: GetTestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List tests (across all targets in tenant)
 */

export function useGetTests<TData = Awaited<ReturnType<typeof getTests>>, TError = unknown>(
 params?: GetTestsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTests>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTestsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create a test (scheduled or immediate)
 */
export type postTestsResponse201 = {
  data: TargetTest
  status: 201
}
    
export type postTestsResponseSuccess = (postTestsResponse201) & {
  headers: Headers;
};
;

export type postTestsResponse = (postTestsResponseSuccess)

export const getPostTestsUrl = () => {


  

  return `/tests`
}

export const postTests = async (targetTestCreate: TargetTestCreate, options?: RequestInit): Promise<postTestsResponse> => {
  
  return customFetch<postTestsResponse>(getPostTestsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetTestCreate,)
  }
);}




export const getPostTestsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTests>>, TError,{data: TargetTestCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTests>>, TError,{data: TargetTestCreate}, TContext> => {

const mutationKey = ['postTests'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTests>>, {data: TargetTestCreate}> = (props) => {
          const {data} = props ?? {};

          return  postTests(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTestsMutationResult = NonNullable<Awaited<ReturnType<typeof postTests>>>
    export type PostTestsMutationBody = TargetTestCreate
    export type PostTestsMutationError = unknown

    /**
 * @summary Create a test (scheduled or immediate)
 */
export const usePostTests = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTests>>, TError,{data: TargetTestCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTests>>,
        TError,
        {data: TargetTestCreate},
        TContext
      > => {
      return useMutation(getPostTestsMutationOptions(options), queryClient);
    }
    /**
 * @summary Get test
 */
export type getTestsTestIdResponse200 = {
  data: TargetTest
  status: 200
}
    
export type getTestsTestIdResponseSuccess = (getTestsTestIdResponse200) & {
  headers: Headers;
};
;

export type getTestsTestIdResponse = (getTestsTestIdResponseSuccess)

export const getGetTestsTestIdUrl = (testId: string,) => {


  

  return `/tests/${testId}`
}

export const getTestsTestId = async (testId: string, options?: RequestInit): Promise<getTestsTestIdResponse> => {
  
  return customFetch<getTestsTestIdResponse>(getGetTestsTestIdUrl(testId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTestsTestIdQueryKey = (testId: string,) => {
    return [
    `/tests/${testId}`
    ] as const;
    }

    
export const getGetTestsTestIdQueryOptions = <TData = Awaited<ReturnType<typeof getTestsTestId>>, TError = unknown>(testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTestsTestIdQueryKey(testId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTestsTestId>>> = ({ signal }) => getTestsTestId(testId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(testId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTestsTestIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTestsTestId>>>
export type GetTestsTestIdQueryError = unknown


export function useGetTestsTestId<TData = Awaited<ReturnType<typeof getTestsTestId>>, TError = unknown>(
 testId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTestsTestId>>,
          TError,
          Awaited<ReturnType<typeof getTestsTestId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTestsTestId<TData = Awaited<ReturnType<typeof getTestsTestId>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTestsTestId>>,
          TError,
          Awaited<ReturnType<typeof getTestsTestId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTestsTestId<TData = Awaited<ReturnType<typeof getTestsTestId>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get test
 */

export function useGetTestsTestId<TData = Awaited<ReturnType<typeof getTestsTestId>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTestsTestIdQueryOptions(testId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Backend should validate:
- credential_ids is a subset of credentials assigned to the target
- schedule_at must be in the future (if provided)
- scope items are A01..A10

 * @summary Update test (schedule/guidance/notifications/scope/credentials)
 */
export type patchTestsTestIdResponse200 = {
  data: TargetTest
  status: 200
}
    
export type patchTestsTestIdResponseSuccess = (patchTestsTestIdResponse200) & {
  headers: Headers;
};
;

export type patchTestsTestIdResponse = (patchTestsTestIdResponseSuccess)

export const getPatchTestsTestIdUrl = (testId: string,) => {


  

  return `/tests/${testId}`
}

export const patchTestsTestId = async (testId: string,
    targetTestUpdate: TargetTestUpdate, options?: RequestInit): Promise<patchTestsTestIdResponse> => {
  
  return customFetch<patchTestsTestIdResponse>(getPatchTestsTestIdUrl(testId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetTestUpdate,)
  }
);}




export const getPatchTestsTestIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTestsTestId>>, TError,{testId: string;data: TargetTestUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchTestsTestId>>, TError,{testId: string;data: TargetTestUpdate}, TContext> => {

const mutationKey = ['patchTestsTestId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTestsTestId>>, {testId: string;data: TargetTestUpdate}> = (props) => {
          const {testId,data} = props ?? {};

          return  patchTestsTestId(testId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchTestsTestIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchTestsTestId>>>
    export type PatchTestsTestIdMutationBody = TargetTestUpdate
    export type PatchTestsTestIdMutationError = unknown

    /**
 * @summary Update test (schedule/guidance/notifications/scope/credentials)
 */
export const usePatchTestsTestId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTestsTestId>>, TError,{testId: string;data: TargetTestUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchTestsTestId>>,
        TError,
        {testId: string;data: TargetTestUpdate},
        TContext
      > => {
      return useMutation(getPatchTestsTestIdMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete test (only if not started)
 */
export type deleteTestsTestIdResponse204 = {
  data: void
  status: 204
}
    
export type deleteTestsTestIdResponseSuccess = (deleteTestsTestIdResponse204) & {
  headers: Headers;
};
;

export type deleteTestsTestIdResponse = (deleteTestsTestIdResponseSuccess)

export const getDeleteTestsTestIdUrl = (testId: string,) => {


  

  return `/tests/${testId}`
}

export const deleteTestsTestId = async (testId: string, options?: RequestInit): Promise<deleteTestsTestIdResponse> => {
  
  return customFetch<deleteTestsTestIdResponse>(getDeleteTestsTestIdUrl(testId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTestsTestIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTestsTestId>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTestsTestId>>, TError,{testId: string}, TContext> => {

const mutationKey = ['deleteTestsTestId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTestsTestId>>, {testId: string}> = (props) => {
          const {testId} = props ?? {};

          return  deleteTestsTestId(testId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTestsTestIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTestsTestId>>>
    
    export type DeleteTestsTestIdMutationError = unknown

    /**
 * @summary Delete test (only if not started)
 */
export const useDeleteTestsTestId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTestsTestId>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTestsTestId>>,
        TError,
        {testId: string},
        TContext
      > => {
      return useMutation(getDeleteTestsTestIdMutationOptions(options), queryClient);
    }
    /**
 * Starts execution immediately (even if it was scheduled).

 * @summary Run test now
 */
export type postTestsTestIdrunResponse202 = {
  data: TargetTest
  status: 202
}
    
export type postTestsTestIdrunResponseSuccess = (postTestsTestIdrunResponse202) & {
  headers: Headers;
};
;

export type postTestsTestIdrunResponse = (postTestsTestIdrunResponseSuccess)

export const getPostTestsTestIdrunUrl = (testId: string,) => {


  

  return `/tests/${testId}:run`
}

export const postTestsTestIdrun = async (testId: string, options?: RequestInit): Promise<postTestsTestIdrunResponse> => {
  
  return customFetch<postTestsTestIdrunResponse>(getPostTestsTestIdrunUrl(testId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostTestsTestIdrunMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdrun>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdrun>>, TError,{testId: string}, TContext> => {

const mutationKey = ['postTestsTestIdrun'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTestsTestIdrun>>, {testId: string}> = (props) => {
          const {testId} = props ?? {};

          return  postTestsTestIdrun(testId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTestsTestIdrunMutationResult = NonNullable<Awaited<ReturnType<typeof postTestsTestIdrun>>>
    
    export type PostTestsTestIdrunMutationError = unknown

    /**
 * @summary Run test now
 */
export const usePostTestsTestIdrun = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdrun>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTestsTestIdrun>>,
        TError,
        {testId: string},
        TContext
      > => {
      return useMutation(getPostTestsTestIdrunMutationOptions(options), queryClient);
    }
    /**
 * @summary Cancel test
 */
export type postTestsTestIdcancelResponse202 = {
  data: TargetTest
  status: 202
}
    
export type postTestsTestIdcancelResponseSuccess = (postTestsTestIdcancelResponse202) & {
  headers: Headers;
};
;

export type postTestsTestIdcancelResponse = (postTestsTestIdcancelResponseSuccess)

export const getPostTestsTestIdcancelUrl = (testId: string,) => {


  

  return `/tests/${testId}:cancel`
}

export const postTestsTestIdcancel = async (testId: string, options?: RequestInit): Promise<postTestsTestIdcancelResponse> => {
  
  return customFetch<postTestsTestIdcancelResponse>(getPostTestsTestIdcancelUrl(testId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostTestsTestIdcancelMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdcancel>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdcancel>>, TError,{testId: string}, TContext> => {

const mutationKey = ['postTestsTestIdcancel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTestsTestIdcancel>>, {testId: string}> = (props) => {
          const {testId} = props ?? {};

          return  postTestsTestIdcancel(testId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTestsTestIdcancelMutationResult = NonNullable<Awaited<ReturnType<typeof postTestsTestIdcancel>>>
    
    export type PostTestsTestIdcancelMutationError = unknown

    /**
 * @summary Cancel test
 */
export const usePostTestsTestIdcancel = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdcancel>>, TError,{testId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTestsTestIdcancel>>,
        TError,
        {testId: string},
        TContext
      > => {
      return useMutation(getPostTestsTestIdcancelMutationOptions(options), queryClient);
    }
    /**
 * @summary Get current decision prompt (if awaiting decision)
 */
export type getTestsTestIdDecisionResponse200 = {
  data: TestDecisionState
  status: 200
}
    
export type getTestsTestIdDecisionResponseSuccess = (getTestsTestIdDecisionResponse200) & {
  headers: Headers;
};
;

export type getTestsTestIdDecisionResponse = (getTestsTestIdDecisionResponseSuccess)

export const getGetTestsTestIdDecisionUrl = (testId: string,) => {


  

  return `/tests/${testId}/decision`
}

export const getTestsTestIdDecision = async (testId: string, options?: RequestInit): Promise<getTestsTestIdDecisionResponse> => {
  
  return customFetch<getTestsTestIdDecisionResponse>(getGetTestsTestIdDecisionUrl(testId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTestsTestIdDecisionQueryKey = (testId: string,) => {
    return [
    `/tests/${testId}/decision`
    ] as const;
    }

    
export const getGetTestsTestIdDecisionQueryOptions = <TData = Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError = unknown>(testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTestsTestIdDecisionQueryKey(testId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTestsTestIdDecision>>> = ({ signal }) => getTestsTestIdDecision(testId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(testId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTestsTestIdDecisionQueryResult = NonNullable<Awaited<ReturnType<typeof getTestsTestIdDecision>>>
export type GetTestsTestIdDecisionQueryError = unknown


export function useGetTestsTestIdDecision<TData = Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError = unknown>(
 testId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTestsTestIdDecision>>,
          TError,
          Awaited<ReturnType<typeof getTestsTestIdDecision>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTestsTestIdDecision<TData = Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTestsTestIdDecision>>,
          TError,
          Awaited<ReturnType<typeof getTestsTestIdDecision>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTestsTestIdDecision<TData = Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current decision prompt (if awaiting decision)
 */

export function useGetTestsTestIdDecision<TData = Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError = unknown>(
 testId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTestsTestIdDecision>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTestsTestIdDecisionQueryOptions(testId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Post user decision / answer
 */
export type postTestsTestIdDecisionResponse202 = {
  data: TestDecisionState
  status: 202
}
    
export type postTestsTestIdDecisionResponseSuccess = (postTestsTestIdDecisionResponse202) & {
  headers: Headers;
};
;

export type postTestsTestIdDecisionResponse = (postTestsTestIdDecisionResponseSuccess)

export const getPostTestsTestIdDecisionUrl = (testId: string,) => {


  

  return `/tests/${testId}/decision`
}

export const postTestsTestIdDecision = async (testId: string,
    testDecisionAnswer: TestDecisionAnswer, options?: RequestInit): Promise<postTestsTestIdDecisionResponse> => {
  
  return customFetch<postTestsTestIdDecisionResponse>(getPostTestsTestIdDecisionUrl(testId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      testDecisionAnswer,)
  }
);}




export const getPostTestsTestIdDecisionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdDecision>>, TError,{testId: string;data: TestDecisionAnswer}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdDecision>>, TError,{testId: string;data: TestDecisionAnswer}, TContext> => {

const mutationKey = ['postTestsTestIdDecision'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTestsTestIdDecision>>, {testId: string;data: TestDecisionAnswer}> = (props) => {
          const {testId,data} = props ?? {};

          return  postTestsTestIdDecision(testId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTestsTestIdDecisionMutationResult = NonNullable<Awaited<ReturnType<typeof postTestsTestIdDecision>>>
    export type PostTestsTestIdDecisionMutationBody = TestDecisionAnswer
    export type PostTestsTestIdDecisionMutationError = unknown

    /**
 * @summary Post user decision / answer
 */
export const usePostTestsTestIdDecision = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTestsTestIdDecision>>, TError,{testId: string;data: TestDecisionAnswer}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTestsTestIdDecision>>,
        TError,
        {testId: string;data: TestDecisionAnswer},
        TContext
      > => {
      return useMutation(getPostTestsTestIdDecisionMutationOptions(options), queryClient);
    }
    