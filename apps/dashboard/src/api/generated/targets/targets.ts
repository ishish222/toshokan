/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Navigator API
 * Backend API for Navigator (FastAPI). Auth via Cognito JWT; customer tenancy derived from JWT.

 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  GetCustomersCustomerIdTargetsParams,
  GetTargetsParams,
  OwnershipChallenge,
  PagedTargets,
  PostTargetsTargetIdOwnershipVerify200,
  PostTargetsTargetIdOwnershipVerifyBody,
  Target,
  TargetCreate,
  TargetUpdate
} from '.././model';

import { customFetch } from '../../client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary List targets for customer
 */
export type getCustomersCustomerIdTargetsResponse200 = {
  data: PagedTargets
  status: 200
}
    
export type getCustomersCustomerIdTargetsResponseSuccess = (getCustomersCustomerIdTargetsResponse200) & {
  headers: Headers;
};
;

export type getCustomersCustomerIdTargetsResponse = (getCustomersCustomerIdTargetsResponseSuccess)

export const getGetCustomersCustomerIdTargetsUrl = (customerId: string,
    params?: GetCustomersCustomerIdTargetsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/customers/${customerId}/targets?${stringifiedParams}` : `/customers/${customerId}/targets`
}

export const getCustomersCustomerIdTargets = async (customerId: string,
    params?: GetCustomersCustomerIdTargetsParams, options?: RequestInit): Promise<getCustomersCustomerIdTargetsResponse> => {
  
  return customFetch<getCustomersCustomerIdTargetsResponse>(getGetCustomersCustomerIdTargetsUrl(customerId,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomersCustomerIdTargetsQueryKey = (customerId: string,
    params?: GetCustomersCustomerIdTargetsParams,) => {
    return [
    `/customers/${customerId}/targets`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetCustomersCustomerIdTargetsQueryOptions = <TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError = unknown>(customerId: string,
    params?: GetCustomersCustomerIdTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomersCustomerIdTargetsQueryKey(customerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>> = ({ signal }) => getCustomersCustomerIdTargets(customerId,params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomersCustomerIdTargetsQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>>
export type GetCustomersCustomerIdTargetsQueryError = unknown


export function useGetCustomersCustomerIdTargets<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError = unknown>(
 customerId: string,
    params: undefined |  GetCustomersCustomerIdTargetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTargets<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError = unknown>(
 customerId: string,
    params?: GetCustomersCustomerIdTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTargets<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError = unknown>(
 customerId: string,
    params?: GetCustomersCustomerIdTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List targets for customer
 */

export function useGetCustomersCustomerIdTargets<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError = unknown>(
 customerId: string,
    params?: GetCustomersCustomerIdTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomersCustomerIdTargetsQueryOptions(customerId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create target for customer
 */
export type postCustomersCustomerIdTargetsResponse201 = {
  data: Target
  status: 201
}
    
export type postCustomersCustomerIdTargetsResponseSuccess = (postCustomersCustomerIdTargetsResponse201) & {
  headers: Headers;
};
;

export type postCustomersCustomerIdTargetsResponse = (postCustomersCustomerIdTargetsResponseSuccess)

export const getPostCustomersCustomerIdTargetsUrl = (customerId: string,) => {


  

  return `/customers/${customerId}/targets`
}

export const postCustomersCustomerIdTargets = async (customerId: string,
    targetCreate: TargetCreate, options?: RequestInit): Promise<postCustomersCustomerIdTargetsResponse> => {
  
  return customFetch<postCustomersCustomerIdTargetsResponse>(getPostCustomersCustomerIdTargetsUrl(customerId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetCreate,)
  }
);}




export const getPostCustomersCustomerIdTargetsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>, TError,{customerId: string;data: TargetCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>, TError,{customerId: string;data: TargetCreate}, TContext> => {

const mutationKey = ['postCustomersCustomerIdTargets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>, {customerId: string;data: TargetCreate}> = (props) => {
          const {customerId,data} = props ?? {};

          return  postCustomersCustomerIdTargets(customerId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostCustomersCustomerIdTargetsMutationResult = NonNullable<Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>>
    export type PostCustomersCustomerIdTargetsMutationBody = TargetCreate
    export type PostCustomersCustomerIdTargetsMutationError = unknown

    /**
 * @summary Create target for customer
 */
export const usePostCustomersCustomerIdTargets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>, TError,{customerId: string;data: TargetCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postCustomersCustomerIdTargets>>,
        TError,
        {customerId: string;data: TargetCreate},
        TContext
      > => {
      return useMutation(getPostCustomersCustomerIdTargetsMutationOptions(options), queryClient);
    }
    /**
 * @summary Get target for customer
 */
export type getCustomersCustomerIdTargetsTargetIdResponse200 = {
  data: Target
  status: 200
}
    
export type getCustomersCustomerIdTargetsTargetIdResponseSuccess = (getCustomersCustomerIdTargetsTargetIdResponse200) & {
  headers: Headers;
};
;

export type getCustomersCustomerIdTargetsTargetIdResponse = (getCustomersCustomerIdTargetsTargetIdResponseSuccess)

export const getGetCustomersCustomerIdTargetsTargetIdUrl = (customerId: string,
    targetId: string,) => {


  

  return `/customers/${customerId}/targets/${targetId}`
}

export const getCustomersCustomerIdTargetsTargetId = async (customerId: string,
    targetId: string, options?: RequestInit): Promise<getCustomersCustomerIdTargetsTargetIdResponse> => {
  
  return customFetch<getCustomersCustomerIdTargetsTargetIdResponse>(getGetCustomersCustomerIdTargetsTargetIdUrl(customerId,targetId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetCustomersCustomerIdTargetsTargetIdQueryKey = (customerId: string,
    targetId: string,) => {
    return [
    `/customers/${customerId}/targets/${targetId}`
    ] as const;
    }

    
export const getGetCustomersCustomerIdTargetsTargetIdQueryOptions = <TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError = unknown>(customerId: string,
    targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCustomersCustomerIdTargetsTargetIdQueryKey(customerId,targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>> = ({ signal }) => getCustomersCustomerIdTargetsTargetId(customerId,targetId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(customerId && targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCustomersCustomerIdTargetsTargetIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>>
export type GetCustomersCustomerIdTargetsTargetIdQueryError = unknown


export function useGetCustomersCustomerIdTargetsTargetId<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError = unknown>(
 customerId: string,
    targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTargetsTargetId<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError = unknown>(
 customerId: string,
    targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>,
          TError,
          Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCustomersCustomerIdTargetsTargetId<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError = unknown>(
 customerId: string,
    targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get target for customer
 */

export function useGetCustomersCustomerIdTargetsTargetId<TData = Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError = unknown>(
 customerId: string,
    targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCustomersCustomerIdTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCustomersCustomerIdTargetsTargetIdQueryOptions(customerId,targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update target for customer
 */
export type patchCustomersCustomerIdTargetsTargetIdResponse200 = {
  data: Target
  status: 200
}
    
export type patchCustomersCustomerIdTargetsTargetIdResponseSuccess = (patchCustomersCustomerIdTargetsTargetIdResponse200) & {
  headers: Headers;
};
;

export type patchCustomersCustomerIdTargetsTargetIdResponse = (patchCustomersCustomerIdTargetsTargetIdResponseSuccess)

export const getPatchCustomersCustomerIdTargetsTargetIdUrl = (customerId: string,
    targetId: string,) => {


  

  return `/customers/${customerId}/targets/${targetId}`
}

export const patchCustomersCustomerIdTargetsTargetId = async (customerId: string,
    targetId: string,
    targetUpdate: TargetUpdate, options?: RequestInit): Promise<patchCustomersCustomerIdTargetsTargetIdResponse> => {
  
  return customFetch<patchCustomersCustomerIdTargetsTargetIdResponse>(getPatchCustomersCustomerIdTargetsTargetIdUrl(customerId,targetId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetUpdate,)
  }
);}




export const getPatchCustomersCustomerIdTargetsTargetIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>, TError,{customerId: string;targetId: string;data: TargetUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>, TError,{customerId: string;targetId: string;data: TargetUpdate}, TContext> => {

const mutationKey = ['patchCustomersCustomerIdTargetsTargetId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>, {customerId: string;targetId: string;data: TargetUpdate}> = (props) => {
          const {customerId,targetId,data} = props ?? {};

          return  patchCustomersCustomerIdTargetsTargetId(customerId,targetId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchCustomersCustomerIdTargetsTargetIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>>
    export type PatchCustomersCustomerIdTargetsTargetIdMutationBody = TargetUpdate
    export type PatchCustomersCustomerIdTargetsTargetIdMutationError = unknown

    /**
 * @summary Update target for customer
 */
export const usePatchCustomersCustomerIdTargetsTargetId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>, TError,{customerId: string;targetId: string;data: TargetUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchCustomersCustomerIdTargetsTargetId>>,
        TError,
        {customerId: string;targetId: string;data: TargetUpdate},
        TContext
      > => {
      return useMutation(getPatchCustomersCustomerIdTargetsTargetIdMutationOptions(options), queryClient);
    }
    /**
 * @summary List targets for current customer
 */
export type getTargetsResponse200 = {
  data: PagedTargets
  status: 200
}
    
export type getTargetsResponseSuccess = (getTargetsResponse200) & {
  headers: Headers;
};
;

export type getTargetsResponse = (getTargetsResponseSuccess)

export const getGetTargetsUrl = (params?: GetTargetsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/targets?${stringifiedParams}` : `/targets`
}

export const getTargets = async (params?: GetTargetsParams, options?: RequestInit): Promise<getTargetsResponse> => {
  
  return customFetch<getTargetsResponse>(getGetTargetsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTargetsQueryKey = (params?: GetTargetsParams,) => {
    return [
    `/targets`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getGetTargetsQueryOptions = <TData = Awaited<ReturnType<typeof getTargets>>, TError = unknown>(params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargets>>> = ({ signal }) => getTargets(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetsQueryResult = NonNullable<Awaited<ReturnType<typeof getTargets>>>
export type GetTargetsQueryError = unknown


export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = unknown>(
 params: undefined |  GetTargetsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = unknown>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargets>>,
          TError,
          Awaited<ReturnType<typeof getTargets>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = unknown>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List targets for current customer
 */

export function useGetTargets<TData = Awaited<ReturnType<typeof getTargets>>, TError = unknown>(
 params?: GetTargetsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargets>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Create target for current customer
 */
export type postTargetsResponse201 = {
  data: Target
  status: 201
}
    
export type postTargetsResponseSuccess = (postTargetsResponse201) & {
  headers: Headers;
};
;

export type postTargetsResponse = (postTargetsResponseSuccess)

export const getPostTargetsUrl = () => {


  

  return `/targets`
}

export const postTargets = async (targetCreate: TargetCreate, options?: RequestInit): Promise<postTargetsResponse> => {
  
  return customFetch<postTargetsResponse>(getPostTargetsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetCreate,)
  }
);}




export const getPostTargetsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargets>>, TError,{data: TargetCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTargets>>, TError,{data: TargetCreate}, TContext> => {

const mutationKey = ['postTargets'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTargets>>, {data: TargetCreate}> = (props) => {
          const {data} = props ?? {};

          return  postTargets(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTargetsMutationResult = NonNullable<Awaited<ReturnType<typeof postTargets>>>
    export type PostTargetsMutationBody = TargetCreate
    export type PostTargetsMutationError = unknown

    /**
 * @summary Create target for current customer
 */
export const usePostTargets = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargets>>, TError,{data: TargetCreate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTargets>>,
        TError,
        {data: TargetCreate},
        TContext
      > => {
      return useMutation(getPostTargetsMutationOptions(options), queryClient);
    }
    /**
 * @summary Get target
 */
export type getTargetsTargetIdResponse200 = {
  data: Target
  status: 200
}
    
export type getTargetsTargetIdResponseSuccess = (getTargetsTargetIdResponse200) & {
  headers: Headers;
};
;

export type getTargetsTargetIdResponse = (getTargetsTargetIdResponseSuccess)

export const getGetTargetsTargetIdUrl = (targetId: string,) => {


  

  return `/targets/${targetId}`
}

export const getTargetsTargetId = async (targetId: string, options?: RequestInit): Promise<getTargetsTargetIdResponse> => {
  
  return customFetch<getTargetsTargetIdResponse>(getGetTargetsTargetIdUrl(targetId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTargetsTargetIdQueryKey = (targetId: string,) => {
    return [
    `/targets/${targetId}`
    ] as const;
    }

    
export const getGetTargetsTargetIdQueryOptions = <TData = Awaited<ReturnType<typeof getTargetsTargetId>>, TError = unknown>(targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTargetsTargetIdQueryKey(targetId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTargetsTargetId>>> = ({ signal }) => getTargetsTargetId(targetId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(targetId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTargetsTargetIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTargetsTargetId>>>
export type GetTargetsTargetIdQueryError = unknown


export function useGetTargetsTargetId<TData = Awaited<ReturnType<typeof getTargetsTargetId>>, TError = unknown>(
 targetId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetsTargetId>>,
          TError,
          Awaited<ReturnType<typeof getTargetsTargetId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetsTargetId<TData = Awaited<ReturnType<typeof getTargetsTargetId>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTargetsTargetId>>,
          TError,
          Awaited<ReturnType<typeof getTargetsTargetId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTargetsTargetId<TData = Awaited<ReturnType<typeof getTargetsTargetId>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get target
 */

export function useGetTargetsTargetId<TData = Awaited<ReturnType<typeof getTargetsTargetId>>, TError = unknown>(
 targetId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTargetsTargetId>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTargetsTargetIdQueryOptions(targetId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * @summary Update target
 */
export type patchTargetsTargetIdResponse200 = {
  data: Target
  status: 200
}
    
export type patchTargetsTargetIdResponseSuccess = (patchTargetsTargetIdResponse200) & {
  headers: Headers;
};
;

export type patchTargetsTargetIdResponse = (patchTargetsTargetIdResponseSuccess)

export const getPatchTargetsTargetIdUrl = (targetId: string,) => {


  

  return `/targets/${targetId}`
}

export const patchTargetsTargetId = async (targetId: string,
    targetUpdate: TargetUpdate, options?: RequestInit): Promise<patchTargetsTargetIdResponse> => {
  
  return customFetch<patchTargetsTargetIdResponse>(getPatchTargetsTargetIdUrl(targetId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      targetUpdate,)
  }
);}




export const getPatchTargetsTargetIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTargetsTargetId>>, TError,{targetId: string;data: TargetUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof patchTargetsTargetId>>, TError,{targetId: string;data: TargetUpdate}, TContext> => {

const mutationKey = ['patchTargetsTargetId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchTargetsTargetId>>, {targetId: string;data: TargetUpdate}> = (props) => {
          const {targetId,data} = props ?? {};

          return  patchTargetsTargetId(targetId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PatchTargetsTargetIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchTargetsTargetId>>>
    export type PatchTargetsTargetIdMutationBody = TargetUpdate
    export type PatchTargetsTargetIdMutationError = unknown

    /**
 * @summary Update target
 */
export const usePatchTargetsTargetId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchTargetsTargetId>>, TError,{targetId: string;data: TargetUpdate}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchTargetsTargetId>>,
        TError,
        {targetId: string;data: TargetUpdate},
        TContext
      > => {
      return useMutation(getPatchTargetsTargetIdMutationOptions(options), queryClient);
    }
    /**
 * @summary Delete target
 */
export type deleteTargetsTargetIdResponse204 = {
  data: void
  status: 204
}
    
export type deleteTargetsTargetIdResponseSuccess = (deleteTargetsTargetIdResponse204) & {
  headers: Headers;
};
;

export type deleteTargetsTargetIdResponse = (deleteTargetsTargetIdResponseSuccess)

export const getDeleteTargetsTargetIdUrl = (targetId: string,) => {


  

  return `/targets/${targetId}`
}

export const deleteTargetsTargetId = async (targetId: string, options?: RequestInit): Promise<deleteTargetsTargetIdResponse> => {
  
  return customFetch<deleteTargetsTargetIdResponse>(getDeleteTargetsTargetIdUrl(targetId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTargetsTargetIdMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTargetsTargetId>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTargetsTargetId>>, TError,{targetId: string}, TContext> => {

const mutationKey = ['deleteTargetsTargetId'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTargetsTargetId>>, {targetId: string}> = (props) => {
          const {targetId} = props ?? {};

          return  deleteTargetsTargetId(targetId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTargetsTargetIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTargetsTargetId>>>
    
    export type DeleteTargetsTargetIdMutationError = unknown

    /**
 * @summary Delete target
 */
export const useDeleteTargetsTargetId = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTargetsTargetId>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTargetsTargetId>>,
        TError,
        {targetId: string},
        TContext
      > => {
      return useMutation(getDeleteTargetsTargetIdMutationOptions(options), queryClient);
    }
    /**
 * Generates a verification string to be used in DNS TXT (or other supported) proof of ownership.

 * @summary (Re)generate ownership verification string
 */
export type postTargetsTargetIdOwnershipResponse200 = {
  data: OwnershipChallenge
  status: 200
}
    
export type postTargetsTargetIdOwnershipResponseSuccess = (postTargetsTargetIdOwnershipResponse200) & {
  headers: Headers;
};
;

export type postTargetsTargetIdOwnershipResponse = (postTargetsTargetIdOwnershipResponseSuccess)

export const getPostTargetsTargetIdOwnershipUrl = (targetId: string,) => {


  

  return `/targets/${targetId}/ownership`
}

export const postTargetsTargetIdOwnership = async (targetId: string, options?: RequestInit): Promise<postTargetsTargetIdOwnershipResponse> => {
  
  return customFetch<postTargetsTargetIdOwnershipResponse>(getPostTargetsTargetIdOwnershipUrl(targetId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getPostTargetsTargetIdOwnershipMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>, TError,{targetId: string}, TContext> => {

const mutationKey = ['postTargetsTargetIdOwnership'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>, {targetId: string}> = (props) => {
          const {targetId} = props ?? {};

          return  postTargetsTargetIdOwnership(targetId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTargetsTargetIdOwnershipMutationResult = NonNullable<Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>>
    
    export type PostTargetsTargetIdOwnershipMutationError = unknown

    /**
 * @summary (Re)generate ownership verification string
 */
export const usePostTargetsTargetIdOwnership = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>, TError,{targetId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTargetsTargetIdOwnership>>,
        TError,
        {targetId: string},
        TContext
      > => {
      return useMutation(getPostTargetsTargetIdOwnershipMutationOptions(options), queryClient);
    }
    /**
 * Backend checks whether verification string exists in DNS TXT (or other configured method).

 * @summary Verify ownership
 */
export type postTargetsTargetIdOwnershipVerifyResponse200 = {
  data: PostTargetsTargetIdOwnershipVerify200
  status: 200
}
    
export type postTargetsTargetIdOwnershipVerifyResponseSuccess = (postTargetsTargetIdOwnershipVerifyResponse200) & {
  headers: Headers;
};
;

export type postTargetsTargetIdOwnershipVerifyResponse = (postTargetsTargetIdOwnershipVerifyResponseSuccess)

export const getPostTargetsTargetIdOwnershipVerifyUrl = (targetId: string,) => {


  

  return `/targets/${targetId}/ownership/verify`
}

export const postTargetsTargetIdOwnershipVerify = async (targetId: string,
    postTargetsTargetIdOwnershipVerifyBody?: PostTargetsTargetIdOwnershipVerifyBody, options?: RequestInit): Promise<postTargetsTargetIdOwnershipVerifyResponse> => {
  
  return customFetch<postTargetsTargetIdOwnershipVerifyResponse>(getPostTargetsTargetIdOwnershipVerifyUrl(targetId),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postTargetsTargetIdOwnershipVerifyBody,)
  }
);}




export const getPostTargetsTargetIdOwnershipVerifyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>, TError,{targetId: string;data: PostTargetsTargetIdOwnershipVerifyBody}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>, TError,{targetId: string;data: PostTargetsTargetIdOwnershipVerifyBody}, TContext> => {

const mutationKey = ['postTargetsTargetIdOwnershipVerify'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>, {targetId: string;data: PostTargetsTargetIdOwnershipVerifyBody}> = (props) => {
          const {targetId,data} = props ?? {};

          return  postTargetsTargetIdOwnershipVerify(targetId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type PostTargetsTargetIdOwnershipVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>>
    export type PostTargetsTargetIdOwnershipVerifyMutationBody = PostTargetsTargetIdOwnershipVerifyBody
    export type PostTargetsTargetIdOwnershipVerifyMutationError = unknown

    /**
 * @summary Verify ownership
 */
export const usePostTargetsTargetIdOwnershipVerify = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>, TError,{targetId: string;data: PostTargetsTargetIdOwnershipVerifyBody}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postTargetsTargetIdOwnershipVerify>>,
        TError,
        {targetId: string;data: PostTargetsTargetIdOwnershipVerifyBody},
        TContext
      > => {
      return useMutation(getPostTargetsTargetIdOwnershipVerifyMutationOptions(options), queryClient);
    }
    